<div class="tmd-doc">
<p></p>
<h1 class="tmd-header-1">
Common Operators
</h1>
<p></p>
<div class="tmd-usual">
Operator operations are the operations using all kinds of operators. This article will introduce common operators in Go. More operators will be introduced in other articles later.
</div>
<p></p>
<h3 class="tmd-header-3">
About Some Descriptions in Operator Explanations
</h3>
<p></p>
<div class="tmd-usual">
This article will only introduce arithmetic operators, bitwise operators, comparison operators, boolean operators and string concatenation operator. These operators are either binary operators or unary operators. A binary operator operation takes two operands and a unary operator operation takes only one operand.
</div>
<p></p>
<div class="tmd-usual">
All the operator operations introduced in this article each returns one result.
</div>
<p></p>
<div class="tmd-usual">
This article doesn't pursue the accuracy of some descriptions. For example, when it says that a binary operator requires the types of its two operands must be the same, what it means is:
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
if both of the two operands are typed values, then their types must be the same one, or one operand can be implicitly converted to the type of the other.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
if only one of the two operands is typed, then the other (untyped) operand must be representable as a value of the type of the typed operand, or the values of the default type of the other (untyped) operand can be implicitly converted to the typed of the typed operand.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
if both operands are untyped values, then they must be both boolean values, both string values or both basic numeric values.
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
Similarly, when it says an operator, either a binary operator or a unary operator, requires the type of one of its operands to be of a certain type, what it means is:
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
if the operand is typed, then its type must be, or can be implicitly converted to, that certain type.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
if the operand is untyped, then the untyped value must be representable as a value of that certain type, or the values of the default type of the operand can be implicitly converted to that certain type.
</div>
</li>
</ul>
<p></p>
<h3 id="constant-expression" class="tmd-header-3">
Constant Expressions
</h3>
<p></p>
<div class="tmd-usual">
Before introducing all kinds of operators, we should know what are constant expressions and a fact in the evaluations of constant expressions. Expressions will get explained in a later article <a href="expressions-and-statements.html">expressions and statements</a>. At present, we just should know that most of the operations mentioned the current article are expressions.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<div class="tmd-usual">
If all the operands involved in an expression are constants, then this expression is called a constant expression. All constant expressions are evaluated at compile time. The evaluation result of a constant expression is still a constant.
</div>
<p></p>
<div class="tmd-usual">
Only if one operand in an expression is not a constant, the expression is called a non-constant expression.
</div>
<p></p>
<h3 class="tmd-header-3">
Arithmetic Operators
</h3>
<p></p>
<div class="tmd-usual">
Go supports five basic binary arithmetic operators:
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Operator
</th>
<th>
Name
</th>
<th>
Requirements for the Two Operands
</th>
</tr>
<tr>
<th>
<code class="tmd-code-span">+</code>
</th>
<td>
<div class="tmd-usual">
addition
</div>
</td>
<td rowspan="4">
<div class="tmd-base">
<div class="tmd-usual">
The two operands must be both values of the same basic numeric type.
</div>
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">-</code>
</th>
<td>
<div class="tmd-usual">
subtraction
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">*</code>
</th>
<td>
<div class="tmd-usual">
multiplication
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">/</code>
</th>
<td>
<div class="tmd-usual">
division
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">%</code>
</th>
<td>
<div class="tmd-usual">
remainder
</div>
</td>
<td>
<div class="tmd-base">
<div class="tmd-usual">
The two operands must be both values of the same basic integer type.
</div>
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
The five operators are also often called <span class="tmd-bold">sum</span>, <span class="tmd-bold">difference</span>, <span class="tmd-bold">product</span>, <span class="tmd-bold">quotient</span> and <span class="tmd-bold">modulo</span> operators, respectively. Go 101 will not explain how these operator operations work in detail.
</div>
<p></p>
<div class="tmd-usual">
Go supports six bitwise binary arithmetic operators:
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Operator
</th>
<th>
Name
</th>
<th>
Requirements for the Two Operands and Mechanism Explanations
</th>
</tr>
<tr>
<th>
<code class="tmd-code-span">&amp;</code>
</th>
<td>
<div class="tmd-usual">
bitwise and
</div>
</td>
<td rowspan="4">
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
The two operands must be both values of the same integer type.
</div>
<p></p>
<div class="tmd-usual">
Mechanism explanations (a value with the subscript <code class="tmd-code-span">2</code> is the binary literal form of the value):
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
<code class="tmd-mono-font">1100<sub>2</sub> &amp; 1010<sub>2</sub></code> results in <code class="tmd-mono-font">1000<sub>2</sub></code>
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<code class="tmd-mono-font">1100<sub>2</sub> | 1010<sub>2</sub></code> results in <code class="tmd-mono-font">1110<sub>2</sub></code>
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<code class="tmd-mono-font">1100<sub>2</sub> ^ 1010<sub>2</sub></code> results in <code class="tmd-mono-font">0110<sub>2</sub></code>
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<code class="tmd-mono-font">1100<sub>2</sub> &amp;^ 1010<sub>2</sub></code> results in <code class="tmd-mono-font">0100<sub>2</sub></code>
</div>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">|</code>
</th>
<td>
<div class="tmd-usual">
bitwise or
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">^</code>
</th>
<td>
<div class="tmd-usual">
bitwise xor
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">&amp;^</code>
</th>
<td>
<div class="tmd-usual">
bitwise clear
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">&lt;&lt;</code>
</th>
<td>
<div class="tmd-usual">
bitwise left shift
</div>
</td>
<td rowspan="2">
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
The left operand must be an integer and the right operand must be also an integer (if it is a constant, then it must be non-negative), their types are not required to be identical. (Note, before Go 1.13, the right operand must be an unsigned integer or an <a href="constants-and-variables.html#untyped-value">untyped</a> integer constant which is representable as an <code class="tmd-code-span">uint</code> value.)
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<div class="tmd-usual">
A negative right operand (must be a non-constant) will cause a panic at run time.
</div>
<p></p>
<div class="tmd-usual">
Mechanism explanations:
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
<code class="tmd-mono-font">1100<sub>2</sub> &lt;&lt; 3</code> results in <code class="tmd-mono-font">1100000<sub>2</sub></code>
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<code class="tmd-mono-font">1100<sub>2</sub> &gt;&gt; 3</code> results in <code class="tmd-mono-font">1<sub>2</sub></code>
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
Note: in a bitwise-right-shift operation, all the freed-up bits at left are filled with the sign bit (the highest bit) of the left operand. For example. if the left operand is an <code class="tmd-code-span">int8</code> value <code class="tmd-code-span">-128</code>, or <code class="tmd-mono-font">10000000<sub>2</sub></code> in the binary literal form, then <code class="tmd-mono-font">10000000<sub>2</sub> &gt;&gt; 2</code> results <code class="tmd-mono-font">11100000<sub>2</sub></code>, a.k.a., <code class="tmd-code-span">-32</code>.
</div>
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">&gt;&gt;</code>
</th>
<td>
<div class="tmd-usual">
bitwise right shift
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
Go also supports three unary arithmetic operators:
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Operator
</th>
<th>
Name
</th>
<th>
Explanations
</th>
</tr>
<tr>
<th>
<code class="tmd-code-span">+</code>
</th>
<td>
<div class="tmd-usual">
positive
</div>
</td>
<td>
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
<code class="tmd-code-span">+n</code> is equivalent to <code class="tmd-code-span">0 + n</code>.
</div>
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">-</code>
</th>
<td>
<div class="tmd-usual">
negative
</div>
</td>
<td>
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
<code class="tmd-code-span">-n</code> is equivalent to <code class="tmd-code-span">0 - n</code>.
</div>
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">^</code>
</th>
<td>
<div class="tmd-usual">
bitwise complement<br/>(bitwise not)
</div>
</td>
<td>
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
<code class="tmd-code-span">^n</code> is equivalent to <code class="tmd-code-span">m ^ n</code>, where <code class="tmd-code-span">m</code> is a value all of which bits are 1. For example, if the type of <code class="tmd-code-span">n</code> is <code class="tmd-code-span">int8</code>, then <code class="tmd-code-span">m</code> is <code class="tmd-code-span">-1</code>, and if the type of <code class="tmd-code-span">n</code> is <code class="tmd-code-span">uint8</code>, then <code class="tmd-code-span">m</code> is <code class="tmd-code-span">0xFF</code>.
</div>
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
Note,
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
in many other languages, bitwise-complement operator is denoted as <code class="tmd-code-span">~</code>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
like many other languages, the addition binary operator <code class="tmd-code-span">+</code> can also be used as <span class="tmd-bold">string concatenation</span> operator, which will be introduced below.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
like C and C++ languages, the multiplication binary operator <code class="tmd-code-span">*</code> can also be used as <span class="tmd-bold">pointer dereference</span> operator, and the bitwise-and operator <code class="tmd-code-span">&amp;</code> can also be used as <span class="tmd-bold">address taking</span> operator. Please read <a href="pointer.html">pointers in Go</a> for details later.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
unlike Java language, Go supports unsigned integer types, so the unsigned shift operator <code class="tmd-code-span">&gt;&gt;&gt;</code> doesn't exist in Go.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
there is no power operator in Go, please use <code class="tmd-code-span">Pow</code> function in the <code class="tmd-code-span">math</code> standard package instead. Code package and package import will be introduced in the next article <a href="packages-and-imports.html">packages and imports</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
the bitwise-clear operator <code class="tmd-code-span">&amp;^</code> is a unique operator in Go. <code class="tmd-code-span">m &amp;^ n</code> is equivalent to <code class="tmd-code-span">m &amp; (^n)</code>.
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
Example:
</div>
<pre class="tmd-code line-numbers">
<code class="language-go">func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// The ones compile okay.
	_ = 12 + 'A' // two numeric untyped operands
	_ = 12 - a   // one untyped and one typed operand
	_ = a * b    // two typed operands
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2
	_, _, _, _ = c | d, c &amp; d, c ^ d, c &amp;^ d
	_, _, _, _ = d &lt;&lt; e, 123 &gt;&gt; e, e &gt;&gt; 3, 0xF &lt;&lt; 0
	_, _, _, _ = -b, +c, ^e, ^-1

	// The following ones fail to compile.
	_ = a % b   // error: a and b are not integers
	_ = a | b   // error: a and b are not integers
	_ = c + e   // error: type mismatching
	_ = b &gt;&gt; 5  // error: b is not an integer
	_ = c &gt;&gt; -5 // error: -5 is not representable as uint

	_ = e &lt;&lt; uint(c) // compiles ok
	_ = e &lt;&lt; c       // only compiles ok since Go 1.13
	_ = e &lt;&lt; -c      // only compiles ok since Go 1.13,
	                 // will cause a panic at run time.
	_ = e &lt;&lt; -1      // error: right operand is negative
}
</code></pre>
<p></p>
<h4 class="tmd-header-4">
About overflows
</h4>
<p></p>
<div class="tmd-usual">
Overflows are not allowed for typed constant values but are allowed for non-constant and untyped constant values, either the values are intermediate or final results. Overflows will be truncated (or wrapped around) for non-constant values, but overflows (for default types) on untyped constant value will not be truncated (or wrapped around).
</div>
<p></p>
<div class="tmd-usual">
Example:
</div>
<pre class="tmd-code line-numbers">
<code class="language-go">// Results are non-constants.
var a, b uint8 = 255, 1
// Compiles ok, higher overflowed bits are truncated.
var c = a + b  // c == 0
// Compiles ok, higher overflowed bits are truncated.
var d = a &lt;&lt; b // d == 254

// Results are untyped constants.
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // overflows int
const R = 'a' + 0x7FFFFFFF          // overflows rune
// The above two lines both compile ok, though the
// two untyped value X and R both overflow their
// respective default types.

// Operation results or conversion results are
// typed values. These lines all fail to compile.
var e = X // error: untyped constant X overflows int
var h = R // error: constant 2147483744 overflows rune
const Y = 128 - int8(1)  // error: 128 overflows int8
const Z = uint8(255) + 1 // error: 256 overflow uint8
</code></pre>
<p></p>
<h4 class="tmd-header-4">
About the results of arithmetic operator operations
</h4>
<p></p>
<div class="tmd-usual">
Except bitwise shift operations, the result of a binary arithmetic operator operation
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
is a typed value of the same type of the two operands if the two operands are both typed values of the same type.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
is a typed value of the same type of the typed operand if only one of the two operands is a typed value. In the computation, the other (untyped) value will be deduced as a value of the type of the typed operand. In other words, the untyped operand will be implicitly converted to the type of the typed operand.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
is still an untyped value if both of the two operands are untyped. The default type of the result value is one of the two default types and it is the one appears latter in this list: <code class="tmd-code-span">int</code>, <code class="tmd-code-span">rune</code>, <code class="tmd-code-span">float64</code>, <code class="tmd-code-span">complex128</code>. For example, if the default type of one untyped operand is <code class="tmd-code-span">int</code>, and the other one is <code class="tmd-code-span">rune</code>, then the default type of the result untyped value is <code class="tmd-code-span">rune</code>.
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
The rules for the result of a bitwise shift operator operation is a little complicated. Firstly, the result value is always an integer value. Whether it is typed or untyped depends on specific scenarios.
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
If the left operand is a typed value (an integer value), then the type of the result is the same as the type of the left operand.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
If the left operand is an untyped value and the right operand is a constant, then the left operand will be always treated as an integer value, if its default type is not an integer type, it must be representable as an untyped integer and its default type will be viewed as <code class="tmd-code-span">int</code>. For such cases, the result is also an untyped value and the default type of the result is the same as the left operand.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
If the left operand is an untyped value and the right operand is a non-constant integer, then the left operand will be first converted to the type it would assume if the bitwise shift operator operation were replaced by its left operand alone. The result is a typed value whose type is the assumed type.
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
Example:
</div>
<pre class="tmd-code line-numbers must-line-numbers">
<code class="language-go">func main() {
	// Three untyped values. Their default
	// types are: int, rune(int32), complex64.
	const X, Y, Z = 2, 'A', 3i

	var a, b int = X, Y // two typed values.

	// The type of d is the default type of Y: rune.
	d := X + Y
	// The type of e is the type of a: int.
	e := Y - a
	// The type of f is the types of a and b: int.
	f := a * b
	// The type of g is Z's default type: complex64.
	g := Z * Y

	// Output: 2 65 (+0.000000e+000+3.000000e+000i)
	println(X, Y, Z)
	// Output: 67 63 130 (+0.000000e+000+1.950000e+002i)
	println(d, e, f, g)
}
</code></pre>
<p></p>
<div class="tmd-usual">
Another example (bitwise shift operations):
</div>
<pre class="tmd-code line-numbers must-line-numbers">
<code class="language-go">const N = 2
// A is an untyped value (default type as int).
const A = 3.0 &lt;&lt; N // A == 12
// B is typed value (type is int8).
const B = int8(3.0) &lt;&lt; N // B == 12

var m = uint(32)
// The following three lines are equivalent to
// each other. In the following two lines, the
// types of the two "1" are both deduced as
// int64, instead of int.
var x int64 = 1 &lt;&lt; m
var y = int64(1 &lt;&lt; m)
var z = int64(1) &lt;&lt; m

// The following line fails to compile.
/*
var _ = 1.23 &lt;&lt; m // error: shift of type float64
*/
</code></pre>
<p></p>
<div id="bitwise-shift-left-operand-type-deduction" class="tmd-usual">
The last rule for bitwise shift operator operation is to avoid the cases that some bitwise shift operations return different results on different architectures but the differences will not be detected in time. For example, if the operand <code class="tmd-code-span">1</code> is deduced as <code class="tmd-code-span">int</code> instead of <code class="tmd-code-span">int64</code>, the bitwise operation at line <span class="tmd-italic">13</span> (or line <span class="tmd-italic">12</span>) will return different results between 32-bit architectures (0) and 64-bit architectures (2<sup>32</sup>), which may produce some bugs hard to detect in time.
</div>
<p></p>
<div class="tmd-usual">
One interesting consequence of the last rule for bitwise shift operator operation is shown in the following code snippet:
</div>
<p></p>
<pre class="tmd-code line-numbers">
<code class="language-go">const n = uint(2)
var m = uint(2)

// The following two lines compile okay.
var _ float64 = 1 &lt;&lt; n
var _ = float64(1 &lt;&lt; n)

// The following two lines fail to compile.
var _ float64 = 1 &lt;&lt; m
var _ = float64(1 &lt;&lt; m)
</code></pre>
<p></p>
<div class="tmd-usual">
The reason of the last two lines failing to compile is they are both equivalent to the followings two line:
</div>
<p></p>
<pre class="tmd-code line-numbers">
<code class="language-go">var _ = float64(1) &lt;&lt; m
var _ = 1.0 &lt;&lt; m // error: shift of type float64
</code></pre>
<p></p>
<div class="tmd-usual">
Another example:
</div>
<p></p>
<pre class="tmd-code line-numbers">
<code class="language-go">package main

const n = uint(8)
var m = uint(8)

func main() {
	println(a, b) // 2 0
}

var a byte = 1 &lt;&lt; n / 128
var b byte = 1 &lt;&lt; m / 128
</code></pre>
<p></p>
<div class="tmd-usual">
The above program prints <code class="tmd-code-span">2 0</code>, because the last two lines are equivalent to
</div>
<p></p>
<pre class="tmd-code line-numbers">
<code class="language-go">var a = byte(int(1) &lt;&lt; n / 128)
var b = byte(1) &lt;&lt; m / 128
</code></pre>
<p></p>
<h4 class="tmd-header-4">
About integer division and remainder operations
</h4>
<p></p>
<div class="tmd-usual">
Assume <code class="tmd-code-span">x</code> and <code class="tmd-code-span">y</code> are two operands of the same integer type, the integer quotient <code class="tmd-code-span">q</code> (<code class="tmd-code-span">= x / y</code>) and remainder <code class="tmd-code-span">r</code> (<code class="tmd-code-span">= x % y</code>) satisfy <code class="tmd-code-span">x == q*y + r</code>, where <code class="tmd-code-span">|r| &lt; |y|</code>. If <code class="tmd-code-span">r</code> is not zero, its sign is the same as <code class="tmd-code-span">x</code> (the dividend). The result of <code class="tmd-code-span">x / y</code> is truncated towards zero.
</div>
<p></p>
<div class="tmd-usual">
If the divisor <code class="tmd-code-span">y</code> is a constant, it must not be zero. If the divisor is zero at run time and it is an integer, a run-time panic occurs. Panics are like exceptions in some other languages. We can learn more about panics in <a href="control-flows-more.html">this article</a>.
</div>
<p></p>
<div class="tmd-usual">
Example:
</div>
<pre class="tmd-code line-numbers">
<code class="language-go">println( 5/3,   5%3)  // 1 2
println( 5/-3,  5%-3) // -1 2
println(-5/3,  -5%3)  // -1 -2
println(-5/-3, -5%-3) // 1 -2

println(5.0 / 3.0)     // 1.666667
println((1-1i)/(1+1i)) // -1i

var a, b = 1.0, 0.0
println(a/b, b/b) // +Inf NaN

_ = int(a)/int(b) // compiles okay but panics at run time.

// The following two lines fail to compile.
println(1.0/0.0) // error: division by zero
println(0.0/0.0) // error: division by zero
</code></pre>
<p></p>
<h4 class="tmd-header-4">
Using <code class="tmd-code-span">op=</code> for binary arithmetic operators
</h4>
<p></p>
<div class="tmd-usual">
For a binary arithmetic operator <code class="tmd-code-span">op</code>, <code class="tmd-code-span">x = x op y</code> can be shortened to <code class="tmd-code-span">x op= y</code>. In the short form, <code class="tmd-code-span">x</code> will be only evaluated once.
</div>
<p></p>
<div class="tmd-usual">
Example:
</div>
<pre class="tmd-code line-numbers">
<code class="language-go">var a, b int8 = 3, 5
a += b
println(a) // 8
a *= a
println(a) // 64
a /= b
println(a) // 12
a %= b
println(a) // 2
b &lt;&lt;= uint(a)
println(b) // 20
</code></pre>
<p></p>
<h4 class="tmd-header-4">
The increment <code class="tmd-code-span">++</code> and decrement <code class="tmd-code-span">--</code> operators
</h4>
<p></p>
<div class="tmd-usual">
Like many other popular languages, Go also supports the increment <code class="tmd-code-span">++</code> and decrement <code class="tmd-code-span">--</code> operators. However, operations using the two operators don't return any results, so such operations can not be used as <a href="expressions-and-statements.html">expressions</a>. The only operand involved in such an operation must be a numeric value, the numeric value must not be a constant, and the <code class="tmd-code-span">++</code> or <code class="tmd-code-span">--</code> operator must follow the operand.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<div class="tmd-usual">
Example:
</div>
<pre class="tmd-code line-numbers">
<code class="language-go">package main

func main() {
	a, b, c := 12, 1.2, 1+2i
	a++ // ok. &lt;=&gt; a += 1 &lt;=&gt; a = a + 1
	b-- // ok. &lt;=&gt; b -= 1 &lt;=&gt; b = b - 1
	c++ // ok

	// The following lines fail to compile.
	/*
	_ = a++
	_ = b--
	_ = c++
	++a
	--b
	++c
	*/
}
</code></pre>
<p></p>
<h3 class="tmd-header-3">
String Concatenation Operator
</h3>
<p></p>
<div class="tmd-usual">
As mentioned above, the addition operator can also be used as string concatenation.
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Operator
</th>
<th>
Name
</th>
<th>
Requirements for the Two Operands
</th>
</tr>
<tr>
<th>
<code class="tmd-mono-font">+</code>
</th>
<td>
<div class="tmd-usual">
string concatenation
</div>
</td>
<td>
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
The two operands must be both values of the same string type.
</div>
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
The <code class="tmd-code-span">op=</code> form also applies for the string concatenation operator.
</div>
<p></p>
<div class="tmd-usual">
Example:
</div>
<pre class="tmd-code line-numbers">
<code class="language-go">println("Go" + "lang") // Golang
var a = "Go"
a += "lang"
println(a) // Golang
</code></pre>
<p></p>
<div class="tmd-usual">
If one of the two operands of a string concatenation operation is a typed string, then the type of the result string is the same as the type of the typed string. If both of the two operands are untyped (constant) strings, the result is also an untyped string value.
</div>
<p></p>
<h3 class="tmd-header-3">
Boolean (a.k.a. Logical) Operators
</h3>
<p></p>
<div class="tmd-usual">
Go supports two boolean binary operators and one boolean unary operator:
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Operator
</th>
<th>
Name
</th>
<th>
Requirements for the Two Operands
</th>
</tr>
<tr>
<th>
<code class="tmd-code-span">&amp;&amp;</code>
</th>
<td>
<div class="tmd-usual">
boolean and (binary)<br/>a.k.a. conditional and
</div>
</td>
<td rowspan="2">
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
The two operands must be both values of the same boolean type.
</div>
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">||</code>
</th>
<td>
<div class="tmd-usual">
boolean or (binary)<br/>a.k.a. conditional or
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-code-span">!</code>
</th>
<td>
<div class="tmd-usual">
boolean not (unary)
</div>
</td>
<td>
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
The type of the only operand must be a boolean type.
</div>
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
We can use the <code class="tmd-code-span">!=</code> operator introduced in the next sub-section as the <span class="tmd-bold">boolean xor</span> operator.
</div>
<p></p>
<div class="tmd-usual">
Mechanism explanations:
</div>
<pre class="tmd-code disable-line-numbers111 fixed-width">
<code class="language-go">// x    y       x &amp;&amp; y   x || y   !x      !y
true    true    true     true     false   false
true    false   false    true     false   true
false   true    false    true     true    false
false   false   false    false    true    true
</code></pre>
<p></p>
<div class="tmd-usual">
If one of the two operands is a typed boolean, then the type of the result boolean is the same as the type of the typed boolean. If both of the two operands are untyped booleans, the result is also an untyped boolean value.
</div>
<p></p>
<h3 class="tmd-header-3">
Comparison Operators
</h3>
<p></p>
<div class="tmd-usual">
Go supports six comparison binary operators:
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Operator
</th>
<th>
Name
</th>
<th>
Requirements for the Two Operands
</th>
</tr>
<tr>
<th>
<code class="tmd-mono-font">==</code>
</th>
<td>
<div class="tmd-usual">
equal to
</div>
</td>
<td rowspan="2">
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
Generally, the types of its two operands must be the same. For detailed rules, please read <a href="value-conversions-assignments-and-comparisons.html#comparison-rules">comparison rules in Go</a>.
</div>
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-mono-font">!=</code>
</th>
<td>
<div class="tmd-usual">
not equal to
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-mono-font">&lt;</code>
</th>
<td>
<div class="tmd-usual">
less than
</div>
</td>
<td rowspan="4">
<div class="tmd-base tmd-align-left">
<div class="tmd-usual">
The two operands must be both values of the same integer type, floating-point type or string type.
</div>
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-mono-font">&lt;=</code>
</th>
<td>
<div class="tmd-usual">
less than or equal to
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-mono-font">&gt;</code>
</th>
<td>
<div class="tmd-usual">
larger than
</div>
</td>
</tr>
<tr>
<th>
<code class="tmd-mono-font">&gt;=</code>
</th>
<td>
<div class="tmd-usual">
larger than or equal to
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
The type of the result of any comparison operation is always an untyped boolean value. If both of the two operands of a comparison operation are constant, the result is also a constant (boolean) value.
</div>
<p></p>
<div class="tmd-usual">
Later, if we say two values are comparable, we mean they can be compared with the <code class="tmd-code-span">==</code> and <code class="tmd-code-span">!=</code> operators. We will learn that values of which types are not comparable later. Values of basic types are all comparable.
</div>
<p></p>
<div class="tmd-usual">
Please note that, not all real numbers can be accurately represented in memory, so comparing two floating-point (or complex) values may be not reliable. We should check whether or not the absolution of the difference of two floating-point values is smaller than a small threshold to judge whether or not the two floating-point values are equal.
</div>
<p></p>
<h3 class="tmd-header-3">
Operator Precedence
</h3>
<p></p>
<div class="tmd-usual">
The following is the operator precedence in Go. Top ones have higher precedence. The operators in the same line have the same precedence. Like many other languages, <code class="tmd-code-span">()</code> can be used to promote precedence.
</div>
<p></p>
<pre class="tmd-code disable-line-numbers111 fixed-width">
<code class="language-go">*   /   %   &lt;&lt;  &gt;&gt;  &amp;   &amp;^
+   -   |   ^
==  !=  &lt;   &lt;=  &gt;   &gt;=
&amp;&amp;
||
</code></pre>
<p></p>
<div class="tmd-usual">
One obvious difference to some other popular languages is that the precedence of <code class="tmd-code-span">&lt;&lt;</code> and <code class="tmd-code-span">&gt;&gt;</code> is higher than <code class="tmd-code-span">+</code> and <code class="tmd-code-span">-</code> in Go.
</div>
<p></p>
<h3 id="constant-expression-more" class="tmd-header-3">
More About Constant Expressions
</h3>
<p></p>
<div class="tmd-usual">
The following declared variable will be initialized as <code class="tmd-code-span">2.2</code> instead of <code class="tmd-code-span">2.7</code>. The reason is the precedence of the division operation is higher than the addition operation, and in the division operation, both <code class="tmd-code-span">3</code> and <code class="tmd-code-span">2</code> are viewed as integers. The evaluation result of <code class="tmd-code-span">3/2</code> is <code class="tmd-code-span">1</code>.
</div>
<p></p>
<pre class="tmd-code line-numbers">
<code class="language-go">var x = 1.2 + 3/2
</code></pre>
<p></p>
<div class="tmd-usual">
The two named constants declared in the following program are not equal. In the first declaration, both <code class="tmd-code-span">3</code> and <code class="tmd-code-span">2</code> are viewed as integers. However, in the second declaration, they are both viewed as floating-point numbers.
</div>
<p></p>
<pre class="tmd-code line-numbers">
<code class="language-go">package main

const x = 3/2*0.1
const y = 0.1*3/2

func main() {
	println(x) // +1.000000e-001
	println(y) // +1.500000e-001
}
</code></pre>
<p></p>
<h3 class="tmd-header-3">
More Operators
</h3>
<p></p>
<div class="tmd-usual">
Same as C/C++, there are two pointer related operators, <code class="tmd-code-span">*</code> and <code class="tmd-code-span">&amp;</code>. Yes the same operator symbols as the multiplication and bitwise-and operators. <code class="tmd-code-span">&amp;</code> is used to take the address of an addressable value, and <code class="tmd-code-span">*</code> is used to dereference a pointer value. Unlike C/C++, in Go, values of pointer types don't support arithmetic operations. For more details, please read <a href="pointer.html">pointers in Go</a> later.
</div>
<p></p>
<div class="tmd-usual">
There are some other operators in Go. They will be introduced and explained in other Go 101 articles.
</div>
<p></p>
</div>
