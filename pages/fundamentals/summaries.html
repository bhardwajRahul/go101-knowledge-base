<div class="tmd-doc">
<h1 class="tmd-header-1">
Some Simple Summaries
</h1>
<p></p>
<div class="tmd-usual">
Index:
</div>
<p></p>
<ul id="summaries.html" class="tmd-list summaries">
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#type-with-underlyings">Types whose values may have indirect underlying parts</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#have-length-types">Types which values can be used as arguments of built-in <code class="tmd-code-span">len</code> function (and <code class="tmd-code-span">cap</code>, <code class="tmd-code-span">close</code>, <code class="tmd-code-span">delete</code>, <code class="tmd-code-span">make</code> functions)</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#container-types">Comparison of built-in container types</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#composite-literals-types">Types which values can be represented with composite literals (<code class="tmd-code-span">T{...}</code>)</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#type-sizes">Value sizes of all kinds of types</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#nil-zero-value-types">Types which zero values can be represented with <code class="tmd-code-span">nil</code></a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#types-can-have-methods">Types we can implement methods for</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#types-can-be-embedded">Types which can be embedded in struct types</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#compile-time-evaluation">Functions whose calls will/may be evaluated at compile time</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#not-addressable">Values that can't be taken addresses</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#not-comparable">Types which don't support comparisons</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#declared-but-unused">Which code elements are allowed to be declared but not used</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#groupable-elements">Named source code elements which can be declared together within <code class="tmd-code-span">()</code></a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#declaration-places">Named source code elements which can be declared both inside functions and outside any functions</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#additional-return">Expressions which evaluation results may contain optional additional values</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#block-forever">Ways to block the current goroutine forever by using the channel mechanism</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#concatenate-strings">Ways to concatenate strings</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#compiler-optimizations">Optimizations made by the standard Go compiler</a>.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
<a href="#panic-cases">Run-time panic and crash cases</a>.
</div>
</li>
</ul>
<p></p>
<div class="tmd-base summaries-items">
<p></p>
<h3 id="type-with-underlyings" class="tmd-header-3">
Types whose values may have indirect underlying parts
</h3>
<p></p>
<div class="tmd-usual">
Types whose values may have indirect underlying parts:
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
string types
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
function types
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
slice types
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
map types
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
channel types
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
interface types
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
The answer is based on the implementation of the standard Go compiler/runtime. In fact, whether or not function values may have indirect underlying parts is hard to prove, and string values and interface values should be viewed as values without indirect underlying parts in logic. Please read <a href="value-part.html">value parts</a> for details.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<h3 id="have-length-types" class="tmd-header-3">
Types which values can be used as arguments of built-in <code class="tmd-code-span">len</code> function (and <code class="tmd-code-span">cap</code>, <code class="tmd-code-span">close</code>, <code class="tmd-code-span">delete</code>, <code class="tmd-code-span">make</code> functions)
</h3>
<p></p>
<table class="tmd-table">
<tr>
<th>

</th>
<th>
len
</th>
<th>
cap
</th>
<th>
close
</th>
<th>
delete
</th>
<th>
make
</th>
</tr>
<tr>
<th>
string
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
</tr>
<tr>
<th>
array<br/>(and array pointer)
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
</tr>
<tr>
<th>
slice
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
map
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
channel
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<p />
<div class="tmd-usual">

</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
Values of above types can also be ranged over in for-range loops.
</div>
<p></p>
<div class="tmd-usual">
Types which values can be used as arguments of built-in function <code class="tmd-code-span">len</code> can be called container types in broad sense.
</div>
<p></p>
<h3 id="container-types" class="tmd-header-3">
Comparison of built-in container types
</h3>
<p></p>
<table class="tmd-table">
<tr>
<th>
Type
</th>
<th>
Can New Elements Be Added into Values?
</th>
<th>
Are Elements of Values Replaceable?
</th>
<th>
Are Elements of Values Addressable?
</th>
<th>
Will Element Accesses Modify Value Lengths?
</th>
<th>
May Values Have Underlying Parts
</th>
</tr>
<tr>
<th>
string
</th>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
Yes<sup>(1)</sup>
</div>
</td>
</tr>
<tr>
<th>
array
</th>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
Yes<sup>(2)</sup>
</div>
</td>
<td>
<div class="tmd-usual">
Yes<sup>(2)</sup>
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
</tr>
<tr>
<th>
slice
</th>
<td>
<div class="tmd-usual">
No<sup>(3)</sup>
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
map
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
channel
</th>
<td>
<div class="tmd-usual">
Yes<sup>(4)</sup>
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
<sup>(1)</sup> For the standard Go compiler/runtime.<br/><sup>(2)</sup> For addressable array values only.<br/><sup>(3)</sup> Generally, a slice value are modified by assigned another slice value to it by overwriting it. Here, such cases are not viewed as "add new elements". In fact, slice lengths can also be modified separately by calling the <code class="tmd-code-span">reflect.SetLen</code> function. Increase the length of a slice by this way is kind of adding new elements into the slice. But the <code class="tmd-code-span">reflect.SetLen</code> function is slow, so it is rarely used.<br/><sup>(4)</sup> For buffered channels which are still not full.
</div>
<p></p>
<h3 id="composite-literals-types" class="tmd-header-3">
Types which values can be represented with composite literals (<code class="tmd-code-span">T{...}</code>)
</h3>
<p></p>
<div class="tmd-usual">
Values of the following four kinds of types can be represented with composite literals:
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Type (<code class="tmd-code-span">T</code>)
</th>
<th>
Is <code class="tmd-code-span">T{}</code> a Zero Value of <code class="tmd-code-span">T</code>?
</th>
</tr>
<tr>
<th>
struct
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
array
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
slice
</th>
<td>
<div class="tmd-usual">
No<br/>(zero value is <code class="tmd-code-span">nil</code>)
</div>
</td>
</tr>
<tr>
<th>
map
</th>
<td>
<div class="tmd-usual">
No<br/>(zero value is <code class="tmd-code-span">nil</code>)
</div>
</td>
</tr>
</table>
<p></p>
<h3 id="type-sizes" class="tmd-header-3">
Value sizes of all kinds of types
</h3>
<p></p>
<div class="tmd-usual">
Please read <a href="value-copy-cost.html">value copy cost</a> for details.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<h3 id="nil-zero-value-types" class="tmd-header-3">
Types which zero values can be represented with <code class="tmd-code-span">nil</code>
</h3>
<p></p>
<div class="tmd-usual">
The zero values of the following types can be represented with <code class="tmd-code-span">nil</code>.
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Type (<code class="tmd-code-span">T</code>)
</th>
<th>
Size of <code class="tmd-code-span">T(nil)</code>
</th>
</tr>
<tr>
<th>
pointer
</th>
<td>
<div class="tmd-usual">
1 word
</div>
</td>
</tr>
<tr>
<th>
slice
</th>
<td>
<div class="tmd-usual">
3 words
</div>
</td>
</tr>
<tr>
<th>
map
</th>
<td>
<div class="tmd-usual">
1 word
</div>
</td>
</tr>
<tr>
<th>
channel
</th>
<td>
<div class="tmd-usual">
1 word
</div>
</td>
</tr>
<tr>
<th>
function
</th>
<td>
<div class="tmd-usual">
1 word
</div>
</td>
</tr>
<tr>
<th>
interface
</th>
<td>
<div class="tmd-usual">
2 words
</div>
</td>
</tr>
</table>
<p></p>
<div class="tmd-usual">
The above listed sizes are for the standard Go compiler. One word means 4 bytes on 32-bit architectures and 8 bytes on 64-bit architectures. and <a href="value-part.html">the indirect underlying parts</a> of a value don't contribute to the size of the value.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<div class="tmd-usual">
The size of a zero value of a type is the same as any other values of the same type.
</div>
<p></p>
<h3 id="types-can-have-methods" class="tmd-header-3">
Types we can implement methods for
</h3>
<p></p>
<div class="tmd-usual">
Please read <a href="method.html">methods in Go</a> for details.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<h3 id="types-can-be-embedded" class="tmd-header-3">
Types which can be embedded in struct types
</h3>
<p></p>
<div class="tmd-usual">
Please read <a href="type-embedding.html#embeddable-types">which types can be embedded</a> for details.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<h3 id="compile-time-evaluation" class="tmd-header-3">
Functions whose calls will/may be evaluated at compile time
</h3>
<p></p>
<div class="tmd-usual">
If a function call is evaluated at compile time, its return results must be constants.
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>
Function
</th>
<th>
Return Type
</th>
<th>
Are Calls Always Evaluated at Compile Time?
</th>
</tr>
<tr>
<th>
unsafe.Sizeof
</th>
<td rowspan="3">
<div class="tmd-base tmd-align-center">
<div class="tmd-usual">
<code class="tmd-code-span">uintptr</code>
</div>
</div>
</td>
<td rowspan="3">
<div class="tmd-base">
<div class="tmd-base tmd-align-center">
<div class="tmd-usual">
Yes, always.
</div>
</div>
<p></p>
<div class="tmd-usual">
<span class="tmd-italic">But please note that the result of such a call is not viewed as a constant if the argument type of the call is a </span><a href="https://go101.org/generics/555-type-constraints-and-parameters.html"><span class="tmd-italic">type parameter</span></a><span class="tmd-italic">.</span>
</div>
<p></p>
<div class="tmd-usual">

</div>
</div>
</td>
</tr>
<tr>
<th>
unsafe.Alignof
</th>
</tr>
<tr>
<th>
unsafe.Offsetof
</th>
</tr>
<tr>
<th>
len
</th>
<td rowspan="2">
<div class="tmd-base tmd-align-center">
<div class="tmd-usual">
<code class="tmd-code-span">int</code>
</div>
</div>
</td>
<td rowspan="2">
<div class="tmd-base">
<div class="tmd-base tmd-align-center">
<div class="tmd-usual">
Not always.
</div>
</div>
<p></p>
<div class="tmd-usual">
From <a href="https://golang.org/ref/spec#Length_and_capacity">Go specification</a>:
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
the expression <code class="tmd-code-span">len(s)</code> is constant if <code class="tmd-code-span">s</code> is a string constant.
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
the expressions <code class="tmd-code-span">len(s)</code> and <code class="tmd-code-span">cap(s)</code> are constants if the type of <code class="tmd-code-span">s</code> is an array or pointer to an array and the expression <code class="tmd-code-span">s</code> does not contain channel receives or (non-constant) function calls.
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
<span class="tmd-italic">Please note that, even if such a function call is evaluated at compile-time, the evaluation result is not viewed as a constant if the argument type of the call is a </span><a href="https://go101.org/generics/555-type-constraints-and-parameters.html"><span class="tmd-italic">type parameter</span></a><span class="tmd-italic">.</span>
</div>
<p></p>
<div class="tmd-usual">

</div>
</div>
</td>
</tr>
<tr>
<th>
cap
</th>
</tr>
<tr>
<th>
real
</th>
<td rowspan="2">
<div class="tmd-base tmd-align-center">
<div class="tmd-usual">
The result is an untyped value. Its default type is <code class="tmd-code-span">float64</code>.
</div>
</div>
</td>
<td rowspan="2">
<div class="tmd-base">
<div class="tmd-base tmd-align-center">
<div class="tmd-usual">
Not always.
</div>
</div>
<p></p>
<div class="tmd-usual">
From <a href="https://golang.org/ref/spec#Constants">Go spec</a>: the expressions <code class="tmd-code-span">real(s)</code> and <code class="tmd-code-span">imag(s)</code> are constants if <code class="tmd-code-span">s</code> is a complex constant.
</div>
<p></p>
<div class="tmd-usual">

</div>
</div>
</td>
</tr>
<tr>
<th>
imag
</th>
</tr>
<tr>
<th>
complex
</th>
<td>
<div class="tmd-usual">
The result is an untyped value. Its default type is <code class="tmd-code-span">complex128</code>.
</div>
</td>
<td>
<div class="tmd-base">
<div class="tmd-base tmd-align-center">
<div class="tmd-usual">
Not always.
</div>
</div>
<p></p>
<div class="tmd-usual">
From <a href="https://golang.org/ref/spec#Constants">Go spec</a>: the expression <code class="tmd-code-span">complex(sr, si)</code> is constant if both <code class="tmd-code-span">sr</code> and <code class="tmd-code-span">si</code> are numeric constants.
</div>
</div>
</td>
</tr>
</table>
<p></p>
<h3 id="not-addressable" class="tmd-header-3">
Addressable and unaddressable values
</h3>
<p></p>
<div class="tmd-usual">
Please read <a href="unofficial-faq.html#unaddressable-values">this FAQ item</a> to get which values are addressable or unaddressable.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<h3 id="not-comparable" class="tmd-header-3">
Types which don't support comparisons
</h3>
<p></p>
<div class="tmd-usual">
Please read <a href="unofficial-faq.html#incomparable-types">this FAQ item</a> to get which values are addressable or unaddressable.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<h3 id="declared-but-unused" class="tmd-header-3">
Which code elements are allowed to be declared but not used
</h3>
<p></p>
<table class="tmd-table">
<tr>
<th>

</th>
<th>
Allowed to Be Declared but Not Used?
</th>
</tr>
<tr>
<th>
import
</th>
<td>
<div class="tmd-usual">
No
</div>
</td>
</tr>
<tr>
<th>
type
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
variable
</th>
<td>
<div class="tmd-usual">
Yes for package-level variables.<br/>No for local variables (for the standard compiler).
</div>
</td>
</tr>
<tr>
<th>
constant
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
function
</th>
<td>
<div class="tmd-usual">
Yes
</div>
</td>
</tr>
<tr>
<th>
label
</th>
<td>
<div class="tmd-usual">
No
</div>
</td>
</tr>
</table>
<p></p>
<h3 id="groupable-elements" class="tmd-header-3">
Named source code elements which can be declared together within <code class="tmd-code-span">()</code>
</h3>
<p></p>
<div class="tmd-usual">
Following source code elements (of the same kind) can be declared together within <code class="tmd-code-span">()</code>:
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
import
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
type
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
variable
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
constant
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
Functions can't be declared together within <code class="tmd-code-span">()</code>. Also labels.
</div>
<p></p>
<h3 id="declaration-places" class="tmd-header-3">
Named source code elements which can be declared both inside functions and outside any functions
</h3>
<p></p>
<div class="tmd-usual">
Following named source code elements can be declared both inside functions and outside any functions:
</div>
<ul class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
type
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
variable
</div>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
constant
</div>
</li>
</ul>
<p></p>
<div class="tmd-usual">
Imports must be declared before declarations of other elements (and after the package clause). Functions can only be declared outside any functions. Anonymous functions can be defined inside other function bodies, but such definitions are not function declarations. Labels must be declared inside functions.
</div>
<p></p>
<h3 id="additional-return" class="tmd-header-3">
Expressions which evaluation results may contain optional additional values
</h3>
<p></p>
<div class="tmd-usual">
The evaluation results of the following expressions may contain optional additional values:
</div>
<p></p>
<table class="tmd-table">
<tr>
<th>

</th>
<th>
Syntax
</th>
<th>
Meaning of The Optional Value (<code class="tmd-code-span">ok</code> in the syntax examples)
</th>
<th>
Will Omitting the Optional Result Affect Program Behavior?
</th>
</tr>
<tr>
<th>
map element access
</th>
<td>
<div class="tmd-usual">
<code class="tmd-code-span">e, ok = aMap[key]</code>
</div>
</td>
<td>
<div class="tmd-usual">
whether or not the accessed key is present in the map
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
</tr>
<tr>
<th>
channel value receive
</th>
<td>
<div class="tmd-usual">
<code class="tmd-code-span">e, ok = &lt;- aChannel</code>
</div>
</td>
<td>
<div class="tmd-usual">
whether or not the received value was sent before the channel was closed
</div>
</td>
<td>
<div class="tmd-usual">
No
</div>
</td>
</tr>
<tr>
<th>
type assertion
</th>
<td>
<div class="tmd-usual">
<code class="tmd-code-span">v, ok = anInterface.(T)</code>
</div>
</td>
<td>
<div class="tmd-usual">
whether or not the dynamic type of the interface value matches the asserted type
</div>
</td>
<td>
<div class="tmd-usual">
Yes<br/>(when the optional bool result is omitted, a panic occurs if the assertion fails.)
</div>
</td>
</tr>
</table>
<p></p>
<h3 id="block-forever" class="tmd-header-3">
Ways to block the current goroutine forever by using the channel mechanism
</h3>
<p></p>
<div class="tmd-usual">
Without importing any package, we can use the following ways to make the current goroutine ‎enter (and stay in) blocking state forever:
</div>
<p></p>
<ol class="tmd-list">
<li class="tmd-list-item">
<div class="tmd-usual">
send a value to a channel which no ones will receive values from
</div>
<pre class="tmd-code disable-line-numbers111">
<code class="language-go">make(chan struct{}) &lt;- struct{}{}
// or
make(chan&lt;- struct{}) &lt;- struct{}{}
</code></pre>
<p></p>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
receive a value from a never-closed channel which no values have been and will be sent to
</div>
<pre class="tmd-code disable-line-numbers111">
<code class="language-go">&lt;-make(chan struct{})
// or
&lt;-make(&lt;-chan struct{})
// or
for range make(&lt;-chan struct{}) {}
</code></pre>
<p></p>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
receive a value from (or send a value to) a nil channel
</div>
<pre class="tmd-code disable-line-numbers111">
<code class="language-go">chan struct{}(nil) &lt;- struct{}{}
// or
&lt;-chan struct{}(nil)
// or
for range chan struct{}(nil) {}
</code></pre>
<p></p>
</li>
<li class="tmd-list-item">
<div class="tmd-usual">
use a bare select block
</div>
<pre class="tmd-code disable-line-numbers111">
<code class="language-go">select{}
</code></pre>
</li>
</ol>
<p></p>
<h3 id="concatenate-strings" class="tmd-header-3">
Ways to concatenate strings
</h3>
<p></p>
<div class="tmd-usual">
Please read <a href="string.html#string-concatenation">strings in Go</a> for details.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<h3 id="compiler-optimizations" class="tmd-header-3">
Optimizations made by the standard Go compiler
</h3>
<p></p>
<div class="tmd-usual">
Please read the <a href="https://go101.org/optimizations/101.html">Go Optimizations 101</a> book.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
<h3 id="panic-cases" class="tmd-header-3">
Run-time panic and crash cases
</h3>
<p></p>
<div class="tmd-usual">
Please read <a href="https://github.com/go101/go101/wiki/Panic-and-crash-cases">the Go 101 wiki article</a> for this summary.
</div>
<p></p>
<div class="tmd-usual">

</div>
<p></p>
</div>
<p></p>
<div class="tmd-usual">
todo: kinds of control flow blocks control flow statements return, break, fallthrough, continue, goto which control flow statements can be followed a label. which control flow statements can appear in which control flow blocks
</div>
<p></p>
</div>
